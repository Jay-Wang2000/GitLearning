# 继承

# 黑盒复用：通过接口功能复用，内部不可见

**水平关系：关联，聚合，组合，依赖**

### 作用：功能和使用者相互独立，可以独立地维护

### 缺点：要求功能实现良好，在各种情况下使用时不需要修改，可以不可见

# 白盒复用：完全透明地代码复用

**垂直关系：继承**

# 一、语法格式与基本特点

### class <派生类名>:<继承方式><基类名称>,···{ }；

### 特点：

- 派生类可以作为基类，即可以继续派生
- 继承方式决定基类非private的成员在派生类中的访问控制，缺省时为private
- 在public下，基类称为父类，派生类称为子类
- 单继承、多重继承

# 二、派生类的成员

## 1、成员=构造，拷贝，析构，赋值，自动转换+派生类定义+基类(除构造，拷贝，析构，赋值，自动转换)中的数据成员+成员函数

## 2、大小=基类(≥1)+派生类定义的数据成员

**在内存中基类成员放在上面，派生类放在下面**

## 3、[访问控制](../%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb.md)

继承方式决定基类非private的成员在派生类中的访问控制

public不改变

protected和private改变

缺省时为private

![%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled.png](%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled.png)

基类中private成员在派生类中变为不可访问的，用于支持原来类中的成员函数

## 4、构造、拷贝、赋值、析构

先构造基类，再构造派生：指明参数则调用有参构造，无则自动寻找无参构造函数

![%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%201.png](%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%201.png)

先拷贝基类，再拷贝派生：调用基类的拷贝，再处理派生的数据

![%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%202.png](%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%202.png)

先赋值基类，再赋值派生

先析构派生，再析构基类：自动调用基类

# 三、继承的意义(从接口角度来看)

## 使用条件：基类的源代码必须有

## public:is a kind of ;is a; like a

子类几乎一样地继承父类，在父类上加东西，

### 从逻辑上来看，父类是子类的泛化

### 从语言上来看，是子类到父类是public行为集的窄化

## private和protected：has a;cotain a;implement of

子类的接口不受父类影响，父类只是帮助子类实现其功能，protected是保证父类的内部的可访问性，以便在多层继承中private一直存在保持这种关系，让public可以调用

## 优势：可以用继承树的上端的类型参数接受其子树的所有类型

![%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%203.png](%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%203.png)

# 四、类型转换

## 1、私有继承：父类子类不允许相互类型转换

**接口完全不重合，转换无实际意义**

## 2、公有继承：

### (1) 子类到父类的向上类型转换：编译器自动转换

**内部前提：派生类的存储是先存储父类的数据成员，再存储派生类新定义的数据成员**

从逻辑上来看，父类是子类的泛化

从语言上来看，是子类到父类是public行为集的窄化

## 从内部实现来看，只是将指针或引用指向类的内存大小，或者是将对象的大小进行裁剪

### 所以指针更加安全，避免了数据丢失

### (2) 父类到子类的向下类型转化：[使用动态类型转换操作符](../c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6.md)

内部运行：不一定能成功，检查该父类的地址下是否能够看作是该父类的T型子类（检查存储空间）

![%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%204.png](%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%204.png)

# 五、多重继承：两个以上的基类

## 构造时严格按继承顺序构造，再构造派生类，析构与其顺序相反

## 导致基类间成员名字冲突问题：

1. 使用时说明名词空间T::（不推荐）
2. 使用using关键字using T::（不推荐）

### 菱形结构

![%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%205.png](%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb/Untitled%205.png)

就算是使用了不同的名字，也可能出现名字冲突

## 解决数据成员冲突

### 虚基类的解决方案：

viture关键字：基类使用指针来表示，在派生类的实例化中基类延后创建，直到创建结束后再确定每个指针的值

### 其他解决方案：

- 限定只能单继承
- 至多只能有一个基类有非private非静态(再全局区)数据成员(定义一个有行为集的种类)

## 解决成员函数冲突

### 静态编联：

不管该对象有没有可能是派生类转换到父类，在不知道该对象内存情况下，编译期就决定哪个函数转到哪个地址

### 动态编联：[编译器考察对象的相邻地址内存](../c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6.md)(是否有动态内存转换的可能性)：虚机制

关键字：virtual **+实例对象**

静态成员函数、构造函数和拷贝构造函数不能是虚的

析构函数可以是虚函数，且如果类中有其他虚函数，那么析构函数一定是虚函数

赋值函数通常不定义为虚函数
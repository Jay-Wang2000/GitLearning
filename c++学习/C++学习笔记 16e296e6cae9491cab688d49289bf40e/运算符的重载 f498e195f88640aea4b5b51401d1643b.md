# 运算符的重载

除一定的运算符不能重载外其它都可以

要求：

- 参与运算成员至少有一个不是内置类型
- 不能改变运算符的返回值类型，优先级
- 不能定义新的运算符

operate关键字：与转义相似，用于表示已经被占用的关键字或是有特殊含义的关键字：如回车，括号，这里用于让编译器知道这是在进行运算符的重载

### 重载时需要考虑返回值，一般用整数做参考，看运算符是否改变成员而选择bool(!)或TVector(+,-,*,/)或TVector &(=,++,—,+=,-=)类型，需考虑要不要带const(值返回不带，&*返回再说)

# 一、二元运算符的重载：

## 1、自由函数的形式

### 返回值类型 operater运算符(const TVector& v1,TVector v2)

TVector a,b;a+b;时，自动调用 operator +(a,b)

由于数据实例大多是private，故类外函数无法调用，可以在类内声明该函数为友元函数

## 2、成员函数的形式

### 返回值类型 operater运算符(const TVector& rhs) const

隐含了this指针作为第一个参数

TVector a,b;a+b;时，自动调用 a.operator +(b)

## 二元运算符的成对重载：(+=,+)(-=,-)

### +=的重载作为成员函数，+的重载作为自由函数调用+=重载

优点：

- 可以避免使用friend
- 通过修改+=可以一起修改+，提高程序封装性

### 函数选择：

![%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%20f498e195f88640aea4b5b51401d1643b/Untitled.png](%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%20f498e195f88640aea4b5b51401d1643b/Untitled.png)

如果左操作数为自定义类型，就用成员函数

如果没有的话需要满足交换律，如1+a用成员函数无法调用

不能重载&& || ，运算符因为有左右计算顺序的硬性要求
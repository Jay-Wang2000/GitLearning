# c++的导出类型

![%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(ADT)%2005b2dfc8feba43b793810619a2af965e/Untitled.png](%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(ADT)%2005b2dfc8feba43b793810619a2af965e/Untitled.png)

# 一、指针：用于保存地址，本质上是int类表示地址的变量

空指针初始化：使用nullptr，而非NULL，NULL其实是标准库里的define成0的替换用来提高程序可读性

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled.png)

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%201.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%201.png)

# 二、数组：

现代理解，先确定类型，再确定变量

int a[5]→int[5] a 表示存放5个整型定值的变量a

int * p[5]→int *[5] p 表示存放5个整型定值的变量p(*为修饰符，表示*后的量为地址）

int (*p)[5]→int [5] (**p) 表示存放5个整型变量定值的变量（*p），p为指针

# 三、引用：给变量另起别名，作用与原变量相同（读写）

### 对比指针：

- 引用的初始化不能缺省，不能引用空类型必须具体定义，不能引用数组

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%202.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%202.png)

- 引用的对象一经定义不能改变
- 指针可以使用空类型作转换，可以自由修改指向的地址
- 内部实现相同，都是指针

## 常量：

### #define

可以使用变量替换 如 #define f(x) #x 或 #define g(x) n##x

则 f(2)→2 g(2)→n2 双#代表链接

系统宏替换 _LINE_  _FILE_ _FUNCTION_

### 命名常量（const，enum中的int为const）：常量折叠

const int a虽然为定义，如果放在头文件中(可以选择在头文件或cpp中定义)，编译器编译时对a进行常量替换，不为变量分配地址空间，这样，就不存在重复定义引起内存变量栈中的同一变量不同堆空间的问题了

### 引用常量和常量引用

### 指向常量的指针和常量指针

对于同一对象的指针和引用类型的权限只能递减

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%203.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%203.png)

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%204.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%204.png)

引用常量和指向常量的指针都限定了引用和指向的的对象对于变量来说是不变的，不允许通过任何方式通过该变量改变对象（即定义的变量对其对象是只读的），所以const int */& t不可以和int */& t之间进行参数传递或者赋值

常量引用和常量指针说的是该变量是常量，其对象可以修改，但是该变量指向的地址不能修改

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/IMG_0225(20210615-104334).png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/IMG_0225(20210615-104334).png)

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%205.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%205.png)

## 类型转换操作符

### (1) 强制类型转换：static_cast<T>(exp) （<>,()不可省略）

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%206.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%206.png)

### (3) 添加和移除const和volatile约束：const_cast <T>(exp)

volitaile:易变类型，多线程中的数据同步问题（读写）

## 3、类型转换操作符

### (1) 强制类型转换：static_cast<T>(exp) （<>,()不可省略）

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%206.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%206.png)

### (2) 添加和移除const和volatile约束：const_cast <T>(exp)

volitaile:易变类型，多线程中的数据同步问题（读写）

### (3) 表达式重新解释，常用于重新解释函数;reinterpret_cast<T>(exp)

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%207.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%207.png)

### (4) 动态类型转换：[dynamic_cast<T>(exp)](%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb.md)

内部运行：不一定能成功，检查该父类的地址下是否能够看作是该父类的T型子类（检查存储空间）

![c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%208.png](c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6/Untitled%208.png)

### 运行时才能确定能否转换成功，如果等号左端为引用，不报错，一旦转换失败，由于引用定义初始化不能缺省，程序异常
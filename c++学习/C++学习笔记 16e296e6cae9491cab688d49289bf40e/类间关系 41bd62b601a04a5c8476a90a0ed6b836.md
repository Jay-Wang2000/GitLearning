# 类间关系

# 单向联系，双向联系

# 物理联系：

### 编译期依赖：代码层面的，类的定义不在同一个头文件中，但编译按文件编译

![%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/Untitled.png](%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/Untitled.png)

尽可能不使用对象成员：编译需要具体包括这个对象，文件依赖性

数据成员的引用形式会导致需要自定义赋值拷贝构造函数(T & num)，但是指针可以用(*p)转化成T类来直接使用自定义的赋值拷贝构造函数

而使用指针或引用(软关联):只需要使用前置声明就可以编译通过

尽可能使用指针或引用数据成员，参数以指针或引用的形势传递，不使用值类型的返回类型可以减少对拷贝构造函数的依赖

内联的不足：由于内联函数实现在该头文件中而非在cpp文件中，由于编译单元之间的透明性，函数对变量的依赖等的要求可能难以满足（或使用前置声明来满足）

# 逻辑关系：

![%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/Untitled%201.png](%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/Untitled%201.png)

# 水平关系：

[依赖<组合](%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/%E4%BE%9D%E8%B5%96%20%E7%BB%84%E5%90%88%202fc8866cd68743368fa9e6ba1d54bded.md)

# 垂直关系：

[继承](%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836/%E7%BB%A7%E6%89%BF%20e12646733252481b9f6ec7a2ef5416fb.md)

# 对比

## 水平关系

- 不需要源代码

## 垂直关系

- 必须要源代码

私有(private or protected)继承=组合关系 都代表包含，且负责子类的生存与消亡

### 策略：使用组合代替私有继承，使用public继承表示父类子类关系，用多棵较少的继承树来代替一棵较深的树
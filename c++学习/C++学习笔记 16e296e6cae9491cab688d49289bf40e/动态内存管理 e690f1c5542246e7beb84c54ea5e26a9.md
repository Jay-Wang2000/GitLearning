# 动态内存管理

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled.png)

# 一、面向内存静态内存管理(程序区)：

## 可执行文件的大小，内存大小固定，不用在内存中调度

代码区+

程序结束自动释放：常量数据区+全局数据区(全局+静态)+栈区(自动局部变量)

### 优点：自动生成与释放

### 缺点：作用域，生存期有限，函数件需要靠传参

### 由于作用域的问题，参数文件间依赖性强

# 二、面向内存动态管理：

## 全局堆区(空间大)

关键字：new，delete，最好按new逆序释放

### 1、new T(参数列表)

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%201.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%201.png)

1、2步向操作系统申请内存空间

3步强制转换

参数列表：调用T的相应构造函数

### 2、对数组的空间申请：new T[size]

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%202.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%202.png)

size可以是在执行new时确定值的变量，没有参数列表，调用对象的无参构造函数，碰到对象继续调用，不调用有参构造

如果想要有参数地构造，可以多定义一个class使用单变量的new带参数在class内调用重载的构造函数构造另一个类的对象数组

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%203.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%203.png)

### 3、delete 变量名：释放堆区中的空间（而非栈区）

delete p后释放ｐ指向的堆区空间，但是不删除ｐ

未delete的结果：变量一直在内存中，导致数据泄露

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%204.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%204.png)

# 三、重载new和delete

设置申请和删除的个数，可以在申请的时候多设置一位存放全局堆区中的变量个数，防止程序变量溢出

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%205.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%205.png)

不可以在构造函数中计算，因为对象不一定在全局堆区中

# 四、智能指针：动态+静态的优点

在静态堆栈中用一个类申请指针指向全局堆区中的对象，在该类的对象自动析构时，也会通过指针自动调用全局堆区对象的析构函数

问题：

- 有时难以获得和修改对象类的源代码
- 如果指向的对象未能很好地定义拷贝构造函数，则无法通过该指针拷贝构造

# 五、解决方法：共享指针(在栈区指向堆区对象)：多个指针指向一个对象，写时复制：在写时才复制新对象

## 实现1：在目标类中设置计数量

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%206.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%206.png)

## 实现2:在指针类中对每个对象设置静态计数变量

在拷贝或赋值时同步use

![%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%207.png](%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20e690f1c5542246e7beb84c54ea5e26a9/Untitled%207.png)

### 定位分配：new (地址) T(参数列表)，地址可以在栈区也可以在全局堆区
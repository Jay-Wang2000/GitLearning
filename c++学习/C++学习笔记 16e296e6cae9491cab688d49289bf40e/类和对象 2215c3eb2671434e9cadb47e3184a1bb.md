# 类和对象

# 一、类：自定义类型（操作+属性）

行为：由一个或多个操作实现，操作=成员函数

### class name{

### public:

### private：

   

[成员函数](%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033.md)

[  数据成员](%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%20f9283e2c34214ddaaa02e8f7ffec305e.md)

···}；

ps.一般放入头文件

- 需使用包含警戒避免重复定义
- 需使用前置声明避免循环定义（头文件相互包含）

```cpp
class cat {
void fight(dog &doga)
}
class dog{
void fight(cat &cata)
}
```

在该情况下cat定义会转到dog定义企图完成dog，但在dog定义中又会转到cat企图完成cat的定义

```cpp
class dog;
class cat;
class cat {
void fight(dog &doga)
};
class dog{
void fight(cat &cata)
};
```

这样的前置声明会告诉编译器dog和cat是什么就不用转到相应的定义部分企图搞清楚dog和cat是什么了

- 使用前置声明降低文件件的依赖性

如果要使用相应的类，不要include它而是使用前置声明，这样它对改动不会改动该头文件，减少了修改后编译的工作量

![%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled.png](%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled.png)

# 二、对象：类型的实例化对应一定存储地址，有具体的类型

类型：基本类型+导出类型+抽象类型

### 没有名字的对象称为匿名对象或无名对象，没有在变量栈区对应变量名，过了分号直接释放

## 1、类的对象的大小：

- 只与非静态数据成员有关
- 一个对象只需要存储它的属性
- 但是一定非零（一个对象一定要有它的地址），没有数据成员时为1
- 与字节对齐方式设置有关（8086的两个标志位，为了保证编译速度会设置字节对齐，可能会空出几个字节）

## 2、对象的访问：发送消息

调用函数与发送消息？

## [3、访问控制(类与类之间的访问):即接口的设置](%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%2041bd62b601a04a5c8476a90a0ed6b836.md)

访问：在某类的操作中调用本类或别类的成员和操作

public：任何类都可以访问

protected：本类和派生类可以访问

private:仅本类可以访问

ps. protected 和 private的区别在于派生后是否可以被访问

不可访问

## 4、类成员=类变量+实例变量

### 静态变量：

指在程序执行前系统就为之静态分配（也即在运行时中不再改变分配情况）存储空间的一类变量，与之相对应的是在运行时只暂时存在的自动变量（即局部变量）与以动态分配方式获取存储空间的一些对象，其中自动变量的存储空间在调用栈上分配与释放。

它不存放在栈区，而是全局变量区(变量数据区)，生存周期从申请开始到程序结束在编译前期就可以直接检查，减少了动态申请和释放堆区，入栈出栈的过程，加快编译速度

作用域：局部对应局部，全局对应全局

### (1)类变量与类方法：

特点：静态成员，与类的定义一起存储在程序段中

作用：用于描述类的总体相同而非成员间可以不同的属性，只要申请实例，就是定值

类方法没有this指针，没有const型，因为根本不访问数据实例

调用：使用类名调用

### (2)类方法(static)的使用：使用类名调用

自定义构造函数名：由于实例方法必须有对象才能调用，所以在创建对象时，只能通过类方法调用

![%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled%201.png](%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled%201.png)

### (3)类变量的使用：单件的实现

同名的只在全局变量区中有一个

![%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled%202.png](%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled%202.png)

### 或者使用指针+动态分配变量来实现，通过检查指针是否有值以及在堆区中分配区域来实现与静态数据相同的效果

![%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled%203.png](%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%202215c3eb2671434e9cadb47e3184a1bb/Untitled%203.png)

### 5、抽象类的对象所具有的成员函数和数据成员：实例方法和实例变量

特点：非静态成员，存储在对象变量栈区中，每个对象一个，可以由对象访问

作用：用于描述类下每个实例可以不同的属性

实例方法隐含this指针，类型与调用的引用是否是const有关

### 类方法和实例方法都只能访问各自的成员和方法

故静态变量不能用构造函数初始化
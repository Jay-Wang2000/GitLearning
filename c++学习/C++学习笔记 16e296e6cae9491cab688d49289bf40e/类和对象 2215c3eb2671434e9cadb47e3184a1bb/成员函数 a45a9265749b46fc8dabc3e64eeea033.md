# 成员函数

在参数列表中隐含了this指针,即x(int val)→x(this,int val)

## this指针：指向执行该函数的对象

类型相当于(const) T * const this

**当引用类型调用成员函数，且其类型是const T &时代表该引用的权限为只读，**

**或者函数类型为const 则此时this是const T * const this** 

生存周期：调用的函数内

内部调用过程：s1.x(val);→classname::x(&s1,val)

当函数类型为自定义类型时

classname &代表返回的是某个对象的引用量

## 函数实现

外联实现：用函数调用的方式执行

classname 代表返回某个对象，这个对象是新创建的

类型 classname::成员名(参数列表){ }

内联实现：不需要函数调用，在发送信号处展开代码（只是对编译器的建议）

- 在类定义的时候就将其定义完
- 使用inline关键字，如果inline不在类内，建议放在头文件中使类的定义放在一起提高可读性和类的稳定性

内联的不足：由于内联函数实现在该头文件中而非在cpp文件中，由于编译单元之间的透明性，函数对变量的依赖等的要求可能难以满足（或使用前置声明来满足）

## 常成员函数：在函数后面加一个const(可作为重载依据，匹配时看this的类型)代表告诉编译器该成员函数不修改对象

const修饰的时this指针，类型：const classname* const this

即不可以修改该对象的数据成员[https://www.notion.so/a45a9265749b46fc8dabc3e64eeea033#25850ad8570f4ebc90236297e67f85ff]()

[const T &类型的引用只能调用常成员函数](../c++%E7%9A%84%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%2035b74ab967d84fb4ae0ac34d5a29e3e6.md)

# 构造函数:类对象的定义过程就是调用构造函数

## 一、默认(缺省)的构造函数

当用户没有定义任何形式的构造函数，编译器会提供无参的public构造函数

## 二、自定义构造函数：

名字与类名相同，无返回值，explicit可选，可带缺省参数，可设定访问控制，可重载

explicit：禁止隐式调用(类型的自动转换就是隐式调用构造函数)

![%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled.png](%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled.png)

![%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled%201.png](%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled%201.png)

private自定义构造函数：

![%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled%202.png](%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled%202.png)

由于访问实例函数需要有对象，但函数功能就是创建对象，所以根本没有对象，必须使用类方法实现类型调用即函数类型为static

### 形式：classname():初始化参数列表{    }

## 三、构造=拷贝构造:用已有的构造+初始化构造：凭空构造

本质：重载的构造函数的识别

## 拷贝构造：由已知的对象的数据成员初始化新的对象：(拷贝定义和对象值传递和传值方式值返回)

### 本质：调用以类名为重载的函数

T(const B & b):1(),2(),3()...{        }

### 1、缺省拷贝构造函数：浅拷贝

- 内置类型+导出：按字节浅拷贝
- 自定义类型：调用对象对应类的拷贝构造函数

缺点：在对象生存期结束后自动调用析构函数，如果有指针或引用形式的对象，可能导致对相同堆区空间的释放从而产生段错误

### 2、自定义拷贝构造函数：定义所有的拷贝

禁止拷贝和防止函数值对象值传递：private: T(const My& m){   },即类外不可调用

## 四、析构函数：~+类名，释放对象空间(自定义+缺省)

对于内置类型和导出类型的数据成员，释放空间

对于数据成员中的对象，调用该对象的析构函数

ps.变量由栈区保存，所有构造和析构函数在栈区中对变量的创建和释放顺序相反

## 五、赋值函数：已经存在的同类对象之间赋值

### 1、缺省赋值函数：潜赋值

- 内置类型+导出：按变量浅赋值，如果类内有引用不能赋值，因为引用一经定义的之后就不能再赋值
- 自定义类型：调用对象对应类的赋值函数

缺点，同样存在缺省拷贝的问题，引用除外，因为引用只能定义不能赋值

## 2、自定义赋值函数

              **T&            operate=      ([const]        T&            rhs)**

等号运算符的返回值 关键字 代表选择是否改变右值

为了正确的赋值注意不是值传递

### 实现：

![%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled%203.png](%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20a45a9265749b46fc8dabc3e64eeea033/Untitled%203.png)

这种指针的存在可能导致段错误，自己把自己的区域删除又去访问